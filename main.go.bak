package main

import (
	"crypto/hmac"
	"crypto/sha1"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

type Departure struct {
	StopID                int    `json:"stop_id"`
	RouteID               int    `json:"route_id"`
	RunID                 int    `json:"run_id"`
	RunRef                string `json:"run_ref"`
	DirectionID           int    `json:"direction_id"`
	DisruptionIDs         []int  `json:"disruption_ids"`
	ScheduledDepartureUTC string `json:"scheduled_departure_utc"`
	EstimatedDepartureUTC string `json:"estimated_departure_utc"`
	AtPlatform            bool   `json:"at_platform"`
	PlatformNumber        string `json:"platform_number"`
	Flags                 string `json:"flags"`
	DepartureSequence     int    `json:"departure_sequence"`
}

type DepartureResponse struct {
	Departures []Departure `json:"departures"`
}

func getUrl(request string) (string, error) {
	devId := os.Getenv("PTV_DEVID")
	key := os.Getenv("PTV_KEY")
	if key == "" || devId == "" {
		return "", errors.New("asdf")
		// &error{"failed to get PTV_DEVID or PTV_KEY from environment"}
	}
	baseURL := "http://timetableapi.ptv.vic.gov.au"

	if strings.Contains(request, "?") {
		request = request + "&"
	} else {
		request = request + "?"
	}
	raw := request + fmt.Sprintf("devid=%s", devId)
	h := hmac.New(sha1.New, []byte(key))
	h.Write([]byte(raw))
	signature := hex.EncodeToString(h.Sum(nil))
	url := fmt.Sprintf("%s%s&signature=%s", baseURL, raw, signature)
	fmt.Println(url)
	return url, nil
}

func printFormattedDate(dateObj time.Time) {
	formattedDate := dateObj.Format("15:04 PM")
	fmt.Println(formattedDate)
}

func getDepartures(stopID int, routeID int, queryParams string) ([]Departure, error) {
	requestString := fmt.Sprintf("/v3/departures/route_type/0/stop/%d/route/%d%s", stopID, routeID, queryParams)
	url, err := getUrl(requestString)
	if err != nil {
		return nil, err
	}

	res, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("HTTP error! Status: %d", res.StatusCode)
	}

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var response DepartureResponse
	err = json.Unmarshal(body, &response)
	if err != nil {
		fmt.Println("Error:", err)
	}

	departures := response.Departures
	return departures, nil
}

func getNextDepartureTowards(departures []Departure, directionID int, count int) ([]Departure, error) {
	now := time.Now()

	validDepartures := make([]Departure, 0)
	i := 0

	for _, departure := range departures {
		departureDateStr := departure.ScheduledDepartureUTC
		// departureDateStr, ok := departure["scheduled_departure_utc"].(string)
		// if !ok {
		// 	return nil, fmt.Errorf("failed to parse departure date")
		// }

		departureDate, err := time.Parse(time.RFC3339, departureDateStr)
		if err != nil {
			return nil, err
		}

		// if the train is not going in the direction we want skip it
		if int(departure.DirectionID) != directionID {
			continue
		}

		// if the train already departed skip it
		if departureDate.Before(now) {
			continue
		}

		// add the train to the list of departures to return
		validDepartures = append(validDepartures, departure)

		// if we have returned the number of departures required then return them
		i++
		if i == count {
			return validDepartures, nil
		}
	}

	return validDepartures, nil
}

func main() {
	// get the departures for a stop on a route
	departures, err := getDepartures(1016, 2, "?expand=All&include_geopath=true")
	if err != nil {
		fmt.Println(err)
		return
	}

	// get the next N departures in a certain direction
	nextBWDepartures, err := getNextDepartureTowards(departures, 1, 2)
	if err != nil {
		fmt.Println(err)
		return
	}

	// pretty print like so
	// jsonData, err := json.MarshalIndent(nextBWDepartures[i], "", "  ")
	// fmt.Println(string(jsonData))

	nextDepartures := []string{}
	for i := 0; i < len(nextBWDepartures); i++ {
		if err == nil {
			layout := "2006-01-02T15:04:05Z"
			departureTime, err := time.Parse(layout, nextBWDepartures[i].ScheduledDepartureUTC)
			if err != nil {
				nextDepartures = append(nextDepartures, "ERROR")
			} else {
				formattedTime := departureTime.Format("2-1-2006 3:4 PM")
				nextDepartures = append(nextDepartures, formattedTime)
			}
		}
	}
	fmt.Println(nextDepartures)
}
